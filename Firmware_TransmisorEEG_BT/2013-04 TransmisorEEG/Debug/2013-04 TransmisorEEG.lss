
2013-04 TransmisorEEG.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000aca  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000b3e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000006d  00802000  00802000  00000b3e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b3e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000b70  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000230  00000000  00000000  00000bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002fad  00000000  00000000  00000de0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ba6  00000000  00000000  00003d8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cce  00000000  00000000  00004933  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000550  00000000  00000000  00005604  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000c6b  00000000  00000000  00005b54  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000d7a  00000000  00000000  000067bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001b0  00000000  00000000  00007539  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
   8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
   c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  10:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  14:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  18:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  1c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  20:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  24:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  28:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  2c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  30:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  34:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  38:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__vector_14>
  3c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  40:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  44:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  48:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  4c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  50:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  54:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  58:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  5c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  60:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  64:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  68:	0c 94 e9 03 	jmp	0x7d2	; 0x7d2 <__vector_26>
  6c:	0c 94 2c 04 	jmp	0x858	; 0x858 <__vector_27>
  70:	0c 94 4d 03 	jmp	0x69a	; 0x69a <__vector_28>
  74:	0c 94 0f 03 	jmp	0x61e	; 0x61e <__vector_29>
  78:	0c 94 ec 02 	jmp	0x5d8	; 0x5d8 <__vector_30>
  7c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  80:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  84:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  88:	0c 94 a1 04 	jmp	0x942	; 0x942 <__vector_34>
  8c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  90:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  94:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  98:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  9c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  a0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  a4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  a8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  ac:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  b0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  b4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  b8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  bc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  c0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  c4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  c8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  cc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  d0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  d4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  d8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  dc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  e0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  e4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  e8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  ec:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  f0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  f4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  f8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
  fc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 100:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 104:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 108:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 10c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 110:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 114:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 118:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 11c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 120:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 124:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 128:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 12c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 130:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 134:	0c 94 45 05 	jmp	0xa8a	; 0xa8a <__vector_77>
 138:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 13c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 140:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 144:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 148:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 14c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 150:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 154:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 158:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 15c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 160:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 164:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 168:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 16c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 170:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 174:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 178:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 17c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 180:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 184:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 188:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 18c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 190:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 194:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 198:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 19c:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1a0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1a4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1a8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1ac:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1b0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1b4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1b8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1bc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1c0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1c4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1c8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1cc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1d0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1d4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1d8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1dc:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1e0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1e4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1e8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1ec:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1f0:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1f4:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>
 1f8:	0c 94 10 01 	jmp	0x220	; 0x220 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e2       	ldi	r29, 0x2F	; 47
 206:	de bf       	out	0x3e, r29	; 62

00000208 <__do_clear_bss>:
 208:	20 e2       	ldi	r18, 0x20	; 32
 20a:	a0 e0       	ldi	r26, 0x00	; 0
 20c:	b0 e2       	ldi	r27, 0x20	; 32
 20e:	01 c0       	rjmp	.+2      	; 0x212 <.do_clear_bss_start>

00000210 <.do_clear_bss_loop>:
 210:	1d 92       	st	X+, r1

00000212 <.do_clear_bss_start>:
 212:	ad 36       	cpi	r26, 0x6D	; 109
 214:	b2 07       	cpc	r27, r18
 216:	e1 f7       	brne	.-8      	; 0x210 <.do_clear_bss_loop>
 218:	0e 94 12 01 	call	0x224	; 0x224 <main>
 21c:	0c 94 63 05 	jmp	0xac6	; 0xac6 <_exit>

00000220 <__bad_interrupt>:
 220:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000224 <main>:
volatile char TEST_TEST;


int main(void)
{
	Init32MHz();
 224:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <Init32MHz>
	HabiliteInt(7);
 228:	87 e0       	ldi	r24, 0x07	; 7
 22a:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <HabiliteInt>
	sei();
 22e:	78 94       	sei
	
	PORTB.OUTCLR = (LED_AZUL_bm|LED_VERDE_bm);
 230:	83 e0       	ldi	r24, 0x03	; 3
 232:	80 93 26 06 	sts	0x0626, r24
	PORTB.DIRSET = (LED_VERDE_bm|LED_AZUL_bm);
 236:	80 93 21 06 	sts	0x0621, r24
	
	PW_init(&PW_Ctrl,PW_PDOWN);
 23a:	64 e0       	ldi	r22, 0x04	; 4
 23c:	8d e2       	ldi	r24, 0x2D	; 45
 23e:	90 e2       	ldi	r25, 0x20	; 32
 240:	0e 94 89 04 	call	0x912	; 0x912 <PW_init>
	
	PORTB.OUTSET = LED_VERDE_bm;
 244:	82 e0       	ldi	r24, 0x02	; 2
 246:	80 93 25 06 	sts	0x0625, r24
	
	To_tcd0_Init(&to_d0_ctrl);
 24a:	87 e0       	ldi	r24, 0x07	; 7
 24c:	90 e2       	ldi	r25, 0x20	; 32
 24e:	0e 94 60 05 	call	0xac0	; 0xac0 <To_tcd0_Init>
	To_tcc0_Init(&to_c0_ctrl);
 252:	86 e0       	ldi	r24, 0x06	; 6
 254:	90 e2       	ldi	r25, 0x20	; 32
 256:	0e 94 25 05 	call	0xa4a	; 0xa4a <To_tcc0_Init>
	
	cola_init(&cola_ctrl1,COLA_MAX,&cola1);
 25a:	46 e3       	ldi	r20, 0x36	; 54
 25c:	50 e2       	ldi	r21, 0x20	; 32
 25e:	6b e1       	ldi	r22, 0x1B	; 27
 260:	8f e2       	ldi	r24, 0x2F	; 47
 262:	90 e2       	ldi	r25, 0x20	; 32
 264:	0e 94 41 04 	call	0x882	; 0x882 <cola_init>
	cola_init(&cola_ctrl2,COLA_MAX,&cola2);
 268:	41 e5       	ldi	r20, 0x51	; 81
 26a:	50 e2       	ldi	r21, 0x20	; 32
 26c:	6b e1       	ldi	r22, 0x1B	; 27
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	90 e2       	ldi	r25, 0x20	; 32
 272:	0e 94 41 04 	call	0x882	; 0x882 <cola_init>
	
	BT_Init(&BT_ctrl); 
 276:	81 e2       	ldi	r24, 0x21	; 33
 278:	90 e2       	ldi	r25, 0x20	; 32
 27a:	0e 94 ab 03 	call	0x756	; 0x756 <BT_Init>
	ADS_Init(&ADS_Ctrl, ADS_ENERGIA_LOWPOWER, ADS_DATARATE_LP_250); //Funciona
 27e:	46 e0       	ldi	r20, 0x06	; 6
 280:	60 e0       	ldi	r22, 0x00	; 0
 282:	88 e0       	ldi	r24, 0x08	; 8
 284:	90 e2       	ldi	r25, 0x20	; 32
 286:	0e 94 77 01 	call	0x2ee	; 0x2ee <ADS_Init>

	
	ADS_ConfigChannels(&ADS_Ctrl,  ADS_MODO_CONFIG_NORMAL, ADS_GANANCIA_12);
 28a:	40 e6       	ldi	r20, 0x60	; 96
 28c:	63 e0       	ldi	r22, 0x03	; 3
 28e:	88 e0       	ldi	r24, 0x08	; 8
 290:	90 e2       	ldi	r25, 0x20	; 32
 292:	0e 94 df 01 	call	0x3be	; 0x3be <ADS_ConfigChannels>
	//int j=1;
	
	while(1)
	{	
		
		ADS_Adquiera(&ADS_Ctrl);
 296:	88 e0       	ldi	r24, 0x08	; 8
 298:	90 e2       	ldi	r25, 0x20	; 32
 29a:	0e 94 9e 02 	call	0x53c	; 0x53c <ADS_Adquiera>
				//cola_inserte(&cola_ctrl1,0x40+j);
			//}
			//j++;
		//}
				
		BT_Transmitir(&BT_ctrl); //Definicion pines y adapatar a bluetooth
 29e:	81 e2       	ldi	r24, 0x21	; 33
 2a0:	90 e2       	ldi	r25, 0x20	; 32
 2a2:	0e 94 b5 03 	call	0x76a	; 0x76a <BT_Transmitir>
	}
 2a6:	f7 cf       	rjmp	.-18     	; 0x296 <main+0x72>

000002a8 <ADS_EnviarByte>:
	while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
}

void ADS_EnviarByte(volatile ADS_Control *ADS_Ctrl, 
					char comando)
{
 2a8:	fc 01       	movw	r30, r24
	//Interface serial activa
	PORTC.OUTCLR = PIN_ADS_CS_bm;
 2aa:	80 e1       	ldi	r24, 0x10	; 16
 2ac:	80 93 46 06 	sts	0x0646, r24
	
	//baje bandera de byte enviado
	ADS_Ctrl->banderas &= ~(ADS_BYTE_ENVIADO_bm);
 2b0:	80 81       	ld	r24, Z
 2b2:	8e 7f       	andi	r24, 0xFE	; 254
 2b4:	80 83       	st	Z, r24
	
	//Modo de transmisión
	ADS_Ctrl->modo_com = ADS_MODO_COM_ENVIANDO_BYTE;
 2b6:	81 e0       	ldi	r24, 0x01	; 1
 2b8:	81 83       	std	Z+1, r24	; 0x01
	
	//Cargar dato en registro
	USARTC1.DATA = comando;
 2ba:	e0 eb       	ldi	r30, 0xB0	; 176
 2bc:	f8 e0       	ldi	r31, 0x08	; 8
 2be:	60 83       	st	Z, r22
	
	//Habilite interrupciones de txc
	USARTC1.CTRLA |= (3<<USART_TXCINTLVL_gp);
 2c0:	83 81       	ldd	r24, Z+3	; 0x03
 2c2:	8c 60       	ori	r24, 0x0C	; 12
 2c4:	83 83       	std	Z+3, r24	; 0x03
 2c6:	08 95       	ret

000002c8 <ADS_EnviarArreglo>:
}

void ADS_EnviarArreglo(volatile ADS_Control *ADS_Ctrl,
						char datos_max )
{
 2c8:	fc 01       	movw	r30, r24
	//Interface serial activa
	PORTC.OUTCLR = PIN_ADS_CS_bm;
 2ca:	80 e1       	ldi	r24, 0x10	; 16
 2cc:	80 93 46 06 	sts	0x0646, r24
	
	//Limpie bandera de envío de arreglo
	ADS_Ctrl->banderas &= ~(ADS_ARREGLO_ENVIADO_bm);
 2d0:	80 81       	ld	r24, Z
 2d2:	8d 7f       	andi	r24, 0xFD	; 253
 2d4:	80 83       	st	Z, r24
	
	//Ajuste modo de comunicación
	ADS_Ctrl->modo_com = ADS_MODO_COM_ENVIANDO_ARREGLO;
 2d6:	82 e0       	ldi	r24, 0x02	; 2
 2d8:	81 83       	std	Z+1, r24	; 0x01
	
	//Fije el número de datos
	ADS_Ctrl->datos_max = datos_max;
 2da:	64 8b       	std	Z+20, r22	; 0x14
	ADS_Ctrl->n_datos = 0;
 2dc:	13 8a       	std	Z+19, r1	; 0x13
	
	//envíe el primer dato
	USARTC1.DATA = ADS_Ctrl->arreglo[0];
 2de:	82 81       	ldd	r24, Z+2	; 0x02
 2e0:	e0 eb       	ldi	r30, 0xB0	; 176
 2e2:	f8 e0       	ldi	r31, 0x08	; 8
 2e4:	80 83       	st	Z, r24
	
	//Habilite interrupciones de TXC y de DRE
	USARTC1.CTRLA |= ((3<<USART_TXCINTLVL_gp)|(3<<USART_DREINTLVL_gp));
 2e6:	83 81       	ldd	r24, Z+3	; 0x03
 2e8:	8f 60       	ori	r24, 0x0F	; 15
 2ea:	83 83       	std	Z+3, r24	; 0x03
 2ec:	08 95       	ret

000002ee <ADS_Init>:
volatile extern char contador;

void ADS_Init(volatile ADS_Control *ADS_Ctrl,
		char powermode,
		char datarate)
{
 2ee:	0f 93       	push	r16
 2f0:	1f 93       	push	r17
 2f2:	cf 93       	push	r28
 2f4:	df 93       	push	r29
 2f6:	ec 01       	movw	r28, r24
 2f8:	06 2f       	mov	r16, r22
 2fa:	14 2f       	mov	r17, r20
	//Todas la banderas en 0
	ADS_Ctrl->banderas = 0;
 2fc:	18 82       	st	Y, r1
	
	//Estado inicial 1
	ADS_Ctrl->estado = 1;
 2fe:	81 e0       	ldi	r24, 0x01	; 1
 300:	8f 8b       	std	Y+23, r24	; 0x17
	
	//Configuración de los pines
	//puerto c:
	PORTC.OUTSET = PIN_ADS_CS_bm;
 302:	80 e1       	ldi	r24, 0x10	; 16
 304:	80 93 45 06 	sts	0x0645, r24
	PORTC.OUTCLR = (PIN_ADS_SCK_bm|PIN_ADS_DIN_bm);
 308:	90 ea       	ldi	r25, 0xA0	; 160
 30a:	90 93 46 06 	sts	0x0646, r25
	PORTC.DIRSET = (PIN_ADS_CS_bm|PIN_ADS_SCK_bm|PIN_ADS_DIN_bm);
 30e:	90 eb       	ldi	r25, 0xB0	; 176
 310:	90 93 41 06 	sts	0x0641, r25
	
	//CS es activo bajo
	PORTC.OUTSET = PIN_ADS_CS_bm;
 314:	80 93 45 06 	sts	0x0645, r24
	
	//puerto D:
	PORTD.OUTCLR = (PIN_ADS_START_bm|PIN_ADS_PWD_bm|PIN_ADS_RESET_bm);
 318:	9c e1       	ldi	r25, 0x1C	; 28
 31a:	90 93 66 06 	sts	0x0666, r25
	PORTD.DIRSET = (PIN_ADS_START_bm|PIN_ADS_PWD_bm|PIN_ADS_RESET_bm);
 31e:	90 93 61 06 	sts	0x0661, r25
	//Control de velocidad de transferencia
	//BSEL= fPER/(2fBAUD) - 1
	//1Mbps = 15
	//2Mbps = 7
	//16Mbps = 1
	USARTC1.BAUDCTRLA = 15;
 322:	9f e0       	ldi	r25, 0x0F	; 15
 324:	90 93 b6 08 	sts	0x08B6, r25
	USARTC1.BAUDCTRLB = 0x00;
 328:	10 92 b7 08 	sts	0x08B7, r1
	
	//Modo Master SPI
	USARTC1.CTRLC |= 0b11000010;
 32c:	90 91 b5 08 	lds	r25, 0x08B5
 330:	92 6c       	ori	r25, 0xC2	; 194
 332:	90 93 b5 08 	sts	0x08B5, r25
	
	//Habilite transmisor
	USARTC1.CTRLB |= (USART_TXEN_bm);
 336:	90 91 b4 08 	lds	r25, 0x08B4
 33a:	98 60       	ori	r25, 0x08	; 8
 33c:	90 93 b4 08 	sts	0x08B4, r25
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 340:	25 ed       	ldi	r18, 0xD5	; 213
 342:	2a 95       	dec	r18
 344:	f1 f7       	brne	.-4      	; 0x342 <ADS_Init+0x54>
 346:	00 00       	nop
	//Secuencia de encendido:
	
	//esperar 20us para oscilador estabable
	_delay_us(20);
	//En alto PWD y RESET
	PORTD.OUTSET = (PIN_ADS_PWD_bm|PIN_ADS_RESET_bm);
 348:	98 e1       	ldi	r25, 0x18	; 24
 34a:	90 93 65 06 	sts	0x0665, r25
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 34e:	3f ef       	ldi	r19, 0xFF	; 255
 350:	97 ea       	ldi	r25, 0xA7	; 167
 352:	21 e6       	ldi	r18, 0x61	; 97
 354:	31 50       	subi	r19, 0x01	; 1
 356:	90 40       	sbci	r25, 0x00	; 0
 358:	20 40       	sbci	r18, 0x00	; 0
 35a:	e1 f7       	brne	.-8      	; 0x354 <ADS_Init+0x66>
 35c:	00 c0       	rjmp	.+0      	; 0x35e <ADS_Init+0x70>
 35e:	00 00       	nop
	//Esperar 32ms o 1 s
	_delay_ms(1000);
	//Pulso de reset
	PORTD.OUTCLR = PIN_ADS_RESET_bm;
 360:	80 93 66 06 	sts	0x0666, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 364:	35 e1       	ldi	r19, 0x15	; 21
 366:	3a 95       	dec	r19
 368:	f1 f7       	brne	.-4      	; 0x366 <ADS_Init+0x78>
 36a:	00 00       	nop
	//Espere 2us
	_delay_us(2);
	//Fin pulso de reset
	PORTD.OUTSET = PIN_ADS_RESET_bm;
 36c:	80 93 65 06 	sts	0x0665, r24
 370:	80 e6       	ldi	r24, 0x60	; 96
 372:	8a 95       	dec	r24
 374:	f1 f7       	brne	.-4      	; 0x372 <ADS_Init+0x84>
	//Empiece comunicación
	//Interfaz serial activa:
	//PORTC.OUTCLR = PIN_ADS_CS_bm;
	
	//Detenga conversión Continua
	ADS_EnviarByte(ADS_Ctrl,ADS_SDATAC);
 376:	61 e1       	ldi	r22, 0x11	; 17
 378:	ce 01       	movw	r24, r28
 37a:	0e 94 54 01 	call	0x2a8	; 0x2a8 <ADS_EnviarByte>
	while(!(ADS_Ctrl->banderas & ADS_BYTE_ENVIADO_bm));
 37e:	88 81       	ld	r24, Y
 380:	80 ff       	sbrs	r24, 0
 382:	fd cf       	rjmp	.-6      	; 0x37e <ADS_Init+0x90>
	
	//Configuración del buffer de referencia - referencia de voltaje interna a 2.4V
	ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CONFIG3);
 384:	83 e4       	ldi	r24, 0x43	; 67
 386:	8a 83       	std	Y+2, r24	; 0x02
	ADS_Ctrl->arreglo[1] = 0x00;
 388:	1b 82       	std	Y+3, r1	; 0x03
	ADS_Ctrl->arreglo[2] = 0xc0;
 38a:	80 ec       	ldi	r24, 0xC0	; 192
 38c:	8c 83       	std	Y+4, r24	; 0x04
	ADS_EnviarArreglo(ADS_Ctrl,3);
 38e:	63 e0       	ldi	r22, 0x03	; 3
 390:	ce 01       	movw	r24, r28
 392:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
	//Espere a que se haya enviado el arreglo
	while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 396:	88 81       	ld	r24, Y
 398:	81 ff       	sbrs	r24, 1
 39a:	fd cf       	rjmp	.-6      	; 0x396 <ADS_Init+0xa8>
	
	//Configuración de frecuencia de muestreo y Modo de energía
	ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CONFIG1);
 39c:	81 e4       	ldi	r24, 0x41	; 65
 39e:	8a 83       	std	Y+2, r24	; 0x02
	ADS_Ctrl->arreglo[1] = 0x00;
 3a0:	1b 82       	std	Y+3, r1	; 0x03
	ADS_Ctrl->arreglo[2] = (powermode|datarate);
 3a2:	10 2b       	or	r17, r16
 3a4:	1c 83       	std	Y+4, r17	; 0x04
	//ADS_Ctrl->arreglo[2] = 0b00000110;
	ADS_EnviarArreglo(ADS_Ctrl,3);
 3a6:	63 e0       	ldi	r22, 0x03	; 3
 3a8:	ce 01       	movw	r24, r28
 3aa:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
	//Espere a que se haya enviado el arreglo
	while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 3ae:	88 81       	ld	r24, Y
 3b0:	81 ff       	sbrs	r24, 1
 3b2:	fd cf       	rjmp	.-6      	; 0x3ae <ADS_Init+0xc0>
}
 3b4:	df 91       	pop	r29
 3b6:	cf 91       	pop	r28
 3b8:	1f 91       	pop	r17
 3ba:	0f 91       	pop	r16
 3bc:	08 95       	ret

000003be <ADS_ConfigChannels>:
}

void ADS_ConfigChannels(volatile ADS_Control *ADS_Ctrl,
						char Config_modo,
						char Granancia)
{
 3be:	1f 93       	push	r17
 3c0:	cf 93       	push	r28
 3c2:	df 93       	push	r29
 3c4:	ec 01       	movw	r28, r24
 3c6:	14 2f       	mov	r17, r20
	switch (Config_modo)
 3c8:	62 30       	cpi	r22, 0x02	; 2
 3ca:	a1 f1       	breq	.+104    	; 0x434 <ADS_ConfigChannels+0x76>
 3cc:	60 f4       	brcc	.+24     	; 0x3e6 <ADS_ConfigChannels+0x28>
 3ce:	61 30       	cpi	r22, 0x01	; 1
 3d0:	09 f0       	breq	.+2      	; 0x3d4 <ADS_ConfigChannels+0x16>
 3d2:	8b c0       	rjmp	.+278    	; 0x4ea <ADS_ConfigChannels+0x12c>
	{
		//Configurar canales en corto
		case ADS_MODO_CONFIG_CORTO:
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CONFIG2);
 3d4:	82 e4       	ldi	r24, 0x42	; 66
 3d6:	8a 83       	std	Y+2, r24	; 0x02
			ADS_Ctrl->arreglo[1] = 0x00;
 3d8:	1b 82       	std	Y+3, r1	; 0x03
			ADS_Ctrl->arreglo[2] = 0x00;
 3da:	1c 82       	std	Y+4, r1	; 0x04
			ADS_EnviarArreglo(ADS_Ctrl,3);
 3dc:	63 e0       	ldi	r22, 0x03	; 3
 3de:	ce 01       	movw	r24, r28
 3e0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 3e4:	0f c0       	rjmp	.+30     	; 0x404 <ADS_ConfigChannels+0x46>

void ADS_ConfigChannels(volatile ADS_Control *ADS_Ctrl,
						char Config_modo,
						char Granancia)
{
	switch (Config_modo)
 3e6:	63 30       	cpi	r22, 0x03	; 3
 3e8:	09 f4       	brne	.+2      	; 0x3ec <ADS_ConfigChannels+0x2e>
 3ea:	45 c0       	rjmp	.+138    	; 0x476 <ADS_ConfigChannels+0xb8>
 3ec:	64 30       	cpi	r22, 0x04	; 4
 3ee:	09 f0       	breq	.+2      	; 0x3f2 <ADS_ConfigChannels+0x34>
 3f0:	7c c0       	rjmp	.+248    	; 0x4ea <ADS_ConfigChannels+0x12c>
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
		
		break;
		
		case ADS_MODO_CONFIG_OFF:
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CONFIG2);
 3f2:	82 e4       	ldi	r24, 0x42	; 66
 3f4:	8a 83       	std	Y+2, r24	; 0x02
			ADS_Ctrl->arreglo[1] = 0x00;
 3f6:	1b 82       	std	Y+3, r1	; 0x03
			ADS_Ctrl->arreglo[2] = 0x00;
 3f8:	1c 82       	std	Y+4, r1	; 0x04
			ADS_EnviarArreglo(ADS_Ctrl,3);
 3fa:	63 e0       	ldi	r22, 0x03	; 3
 3fc:	ce 01       	movw	r24, r28
 3fe:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 402:	5c c0       	rjmp	.+184    	; 0x4bc <ADS_ConfigChannels+0xfe>
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CONFIG2);
			ADS_Ctrl->arreglo[1] = 0x00;
			ADS_Ctrl->arreglo[2] = 0x00;
			ADS_EnviarArreglo(ADS_Ctrl,3);
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 404:	88 81       	ld	r24, Y
 406:	81 ff       	sbrs	r24, 1
 408:	fd cf       	rjmp	.-6      	; 0x404 <ADS_ConfigChannels+0x46>
			
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CH1SET);
 40a:	85 e4       	ldi	r24, 0x45	; 69
 40c:	8a 83       	std	Y+2, r24	; 0x02
			ADS_Ctrl->arreglo[1] = 0x07;
 40e:	87 e0       	ldi	r24, 0x07	; 7
 410:	8b 83       	std	Y+3, r24	; 0x03
			ADS_Ctrl->arreglo[2] = (Granancia|ADS_MUX_CORTO);
 412:	11 60       	ori	r17, 0x01	; 1
 414:	1c 83       	std	Y+4, r17	; 0x04
			ADS_Ctrl->arreglo[3] = (Granancia|ADS_MUX_CORTO);
 416:	1d 83       	std	Y+5, r17	; 0x05
			ADS_Ctrl->arreglo[4] = (Granancia|ADS_MUX_CORTO);
 418:	1e 83       	std	Y+6, r17	; 0x06
			ADS_Ctrl->arreglo[5] = (Granancia|ADS_MUX_CORTO);
 41a:	1f 83       	std	Y+7, r17	; 0x07
			ADS_Ctrl->arreglo[6] = (Granancia|ADS_MUX_CORTO);
 41c:	18 87       	std	Y+8, r17	; 0x08
			ADS_Ctrl->arreglo[7] = (Granancia|ADS_MUX_CORTO);
 41e:	19 87       	std	Y+9, r17	; 0x09
			ADS_Ctrl->arreglo[8] = (Granancia|ADS_MUX_CORTO);
 420:	1a 87       	std	Y+10, r17	; 0x0a
			ADS_Ctrl->arreglo[9] = (Granancia|ADS_MUX_CORTO);
 422:	1b 87       	std	Y+11, r17	; 0x0b
			ADS_EnviarArreglo(ADS_Ctrl,10);
 424:	6a e0       	ldi	r22, 0x0A	; 10
 426:	ce 01       	movw	r24, r28
 428:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 42c:	88 81       	ld	r24, Y
 42e:	81 ff       	sbrs	r24, 1
 430:	fd cf       	rjmp	.-6      	; 0x42c <ADS_ConfigChannels+0x6e>
 432:	5b c0       	rjmp	.+182    	; 0x4ea <ADS_ConfigChannels+0x12c>
			
		break;
		
		case ADS_MODO_CONFIG_TEST:
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CONFIG2);
 434:	82 e4       	ldi	r24, 0x42	; 66
 436:	8a 83       	std	Y+2, r24	; 0x02
			ADS_Ctrl->arreglo[1] = 0x00;
 438:	1b 82       	std	Y+3, r1	; 0x03
			//ADS_Ctrl->arreglo[2] = 0x14; //DobleAmplitud 2mv
			ADS_Ctrl->arreglo[2] = 0x10;
 43a:	80 e1       	ldi	r24, 0x10	; 16
 43c:	8c 83       	std	Y+4, r24	; 0x04
			ADS_EnviarArreglo(ADS_Ctrl,3);
 43e:	63 e0       	ldi	r22, 0x03	; 3
 440:	ce 01       	movw	r24, r28
 442:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 446:	88 81       	ld	r24, Y
 448:	81 ff       	sbrs	r24, 1
 44a:	fd cf       	rjmp	.-6      	; 0x446 <ADS_ConfigChannels+0x88>
			
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CH1SET);
 44c:	85 e4       	ldi	r24, 0x45	; 69
 44e:	8a 83       	std	Y+2, r24	; 0x02
			ADS_Ctrl->arreglo[1] = 0x07;
 450:	87 e0       	ldi	r24, 0x07	; 7
 452:	8b 83       	std	Y+3, r24	; 0x03
			ADS_Ctrl->arreglo[2] = (Granancia|ADS_MUX_TEST);
 454:	15 60       	ori	r17, 0x05	; 5
 456:	1c 83       	std	Y+4, r17	; 0x04
			ADS_Ctrl->arreglo[3] = (Granancia|ADS_MUX_TEST);
 458:	1d 83       	std	Y+5, r17	; 0x05
			ADS_Ctrl->arreglo[4] = (Granancia|ADS_MUX_TEST);
 45a:	1e 83       	std	Y+6, r17	; 0x06
			ADS_Ctrl->arreglo[5] = (Granancia|ADS_MUX_TEST);
 45c:	1f 83       	std	Y+7, r17	; 0x07
			ADS_Ctrl->arreglo[6] = (Granancia|ADS_MUX_TEST);
 45e:	18 87       	std	Y+8, r17	; 0x08
			ADS_Ctrl->arreglo[7] = (Granancia|ADS_MUX_TEST);
 460:	19 87       	std	Y+9, r17	; 0x09
			ADS_Ctrl->arreglo[8] = (Granancia|ADS_MUX_TEST);
 462:	1a 87       	std	Y+10, r17	; 0x0a
			ADS_Ctrl->arreglo[9] = (Granancia|ADS_MUX_TEST);	
 464:	1b 87       	std	Y+11, r17	; 0x0b
			ADS_EnviarArreglo(ADS_Ctrl,10);
 466:	6a e0       	ldi	r22, 0x0A	; 10
 468:	ce 01       	movw	r24, r28
 46a:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 46e:	88 81       	ld	r24, Y
 470:	81 ff       	sbrs	r24, 1
 472:	fd cf       	rjmp	.-6      	; 0x46e <ADS_ConfigChannels+0xb0>
 474:	3a c0       	rjmp	.+116    	; 0x4ea <ADS_ConfigChannels+0x12c>
		break;
		
		case ADS_MODO_CONFIG_NORMAL:
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CONFIG2);
 476:	82 e4       	ldi	r24, 0x42	; 66
 478:	8a 83       	std	Y+2, r24	; 0x02
			ADS_Ctrl->arreglo[1] = 0x00;
 47a:	1b 82       	std	Y+3, r1	; 0x03
			ADS_Ctrl->arreglo[2] = 0x10;
 47c:	80 e1       	ldi	r24, 0x10	; 16
 47e:	8c 83       	std	Y+4, r24	; 0x04
			//ADS_Ctrl->arreglo[2] = 0x00;
			ADS_EnviarArreglo(ADS_Ctrl,3);
 480:	63 e0       	ldi	r22, 0x03	; 3
 482:	ce 01       	movw	r24, r28
 484:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 488:	88 81       	ld	r24, Y
 48a:	81 ff       	sbrs	r24, 1
 48c:	fd cf       	rjmp	.-6      	; 0x488 <ADS_ConfigChannels+0xca>
			
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CH1SET);
 48e:	85 e4       	ldi	r24, 0x45	; 69
 490:	8a 83       	std	Y+2, r24	; 0x02
			ADS_Ctrl->arreglo[1] = 0x07;
 492:	87 e0       	ldi	r24, 0x07	; 7
 494:	8b 83       	std	Y+3, r24	; 0x03
			ADS_Ctrl->arreglo[2] = (Granancia|ADS_MUX_TEST);
 496:	81 2f       	mov	r24, r17
 498:	85 60       	ori	r24, 0x05	; 5
 49a:	8c 83       	std	Y+4, r24	; 0x04
			ADS_Ctrl->arreglo[3] = (Granancia|ADS_MUX_TEST); 
 49c:	8d 83       	std	Y+5, r24	; 0x05
			ADS_Ctrl->arreglo[4] = (Granancia|ADS_MUX_NORMAL);
 49e:	1e 83       	std	Y+6, r17	; 0x06
			ADS_Ctrl->arreglo[5] = (Granancia|ADS_MUX_NORMAL);//lECTURA SCRIPT ANDRES
 4a0:	1f 83       	std	Y+7, r17	; 0x07
			ADS_Ctrl->arreglo[6] = (Granancia|ADS_MUX_NORMAL);
 4a2:	18 87       	std	Y+8, r17	; 0x08
			ADS_Ctrl->arreglo[7] = (Granancia|ADS_MUX_NORMAL);
 4a4:	19 87       	std	Y+9, r17	; 0x09
			ADS_Ctrl->arreglo[8] = (Granancia|ADS_MUX_CORTO);
 4a6:	11 60       	ori	r17, 0x01	; 1
 4a8:	1a 87       	std	Y+10, r17	; 0x0a
			ADS_Ctrl->arreglo[9] = (Granancia|ADS_MUX_CORTO);
 4aa:	1b 87       	std	Y+11, r17	; 0x0b

			ADS_EnviarArreglo(ADS_Ctrl,10);
 4ac:	6a e0       	ldi	r22, 0x0A	; 10
 4ae:	ce 01       	movw	r24, r28
 4b0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 4b4:	88 81       	ld	r24, Y
 4b6:	81 ff       	sbrs	r24, 1
 4b8:	fd cf       	rjmp	.-6      	; 0x4b4 <ADS_ConfigChannels+0xf6>
 4ba:	17 c0       	rjmp	.+46     	; 0x4ea <ADS_ConfigChannels+0x12c>
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CONFIG2);
			ADS_Ctrl->arreglo[1] = 0x00;
			ADS_Ctrl->arreglo[2] = 0x00;
			ADS_EnviarArreglo(ADS_Ctrl,3);
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 4bc:	88 81       	ld	r24, Y
 4be:	81 ff       	sbrs	r24, 1
 4c0:	fd cf       	rjmp	.-6      	; 0x4bc <ADS_ConfigChannels+0xfe>
		
			ADS_Ctrl->arreglo[0] = (ADS_WREG|ADS_REG_CH1SET);
 4c2:	85 e4       	ldi	r24, 0x45	; 69
 4c4:	8a 83       	std	Y+2, r24	; 0x02
			ADS_Ctrl->arreglo[1] = 0x07;
 4c6:	87 e0       	ldi	r24, 0x07	; 7
 4c8:	8b 83       	std	Y+3, r24	; 0x03
			ADS_Ctrl->arreglo[2] = (Granancia|ADS_CHN_OFF);
 4ca:	10 68       	ori	r17, 0x80	; 128
 4cc:	1c 83       	std	Y+4, r17	; 0x04
			ADS_Ctrl->arreglo[3] = (Granancia|ADS_CHN_OFF);
 4ce:	1d 83       	std	Y+5, r17	; 0x05
			ADS_Ctrl->arreglo[4] = (Granancia|ADS_CHN_OFF);
 4d0:	1e 83       	std	Y+6, r17	; 0x06
			ADS_Ctrl->arreglo[5] = (Granancia|ADS_CHN_OFF);
 4d2:	1f 83       	std	Y+7, r17	; 0x07
			ADS_Ctrl->arreglo[6] = (Granancia|ADS_CHN_OFF);
 4d4:	18 87       	std	Y+8, r17	; 0x08
			ADS_Ctrl->arreglo[7] = (Granancia|ADS_CHN_OFF);
 4d6:	19 87       	std	Y+9, r17	; 0x09
			ADS_Ctrl->arreglo[8] = (Granancia|ADS_CHN_OFF);
 4d8:	1a 87       	std	Y+10, r17	; 0x0a
			ADS_Ctrl->arreglo[9] = (Granancia|ADS_CHN_OFF);
 4da:	1b 87       	std	Y+11, r17	; 0x0b
			ADS_EnviarArreglo(ADS_Ctrl,10);
 4dc:	6a e0       	ldi	r22, 0x0A	; 10
 4de:	ce 01       	movw	r24, r28
 4e0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ADS_EnviarArreglo>
			//Espere a que se haya enviado el arreglo
			while (!(ADS_Ctrl->banderas & ADS_ARREGLO_ENVIADO_bm));
 4e4:	88 81       	ld	r24, Y
 4e6:	81 ff       	sbrs	r24, 1
 4e8:	fd cf       	rjmp	.-6      	; 0x4e4 <ADS_ConfigChannels+0x126>
		break;
	}
	
	
	//Limpiar banderas de adquisición detenida
	ADS_Ctrl->banderas &= ~(ADS_ADQUISICION_DETENIDA_bm);
 4ea:	88 81       	ld	r24, Y
 4ec:	8f 7e       	andi	r24, 0xEF	; 239
 4ee:	88 83       	st	Y, r24
	
	//Empezar adquisición
	PORTD.OUTSET = PIN_ADS_START_bm;
 4f0:	84 e0       	ldi	r24, 0x04	; 4
 4f2:	80 93 65 06 	sts	0x0665, r24
	
	ADS_EnviarByte(ADS_Ctrl,ADS_RDATAC);
 4f6:	60 e1       	ldi	r22, 0x10	; 16
 4f8:	ce 01       	movw	r24, r28
 4fa:	0e 94 54 01 	call	0x2a8	; 0x2a8 <ADS_EnviarByte>
	//Espere a que se haya enviado el comando
	while (!(ADS_Ctrl->banderas & ADS_BYTE_ENVIADO_bm));
 4fe:	88 81       	ld	r24, Y
 500:	80 ff       	sbrs	r24, 0
 502:	fd cf       	rjmp	.-6      	; 0x4fe <ADS_ConfigChannels+0x140>
	
}
 504:	df 91       	pop	r29
 506:	cf 91       	pop	r28
 508:	1f 91       	pop	r17
 50a:	08 95       	ret

0000050c <ADS_BusqueColaLibre>:
		
	}
}

void ADS_BusqueColaLibre(volatile ADS_Control *ADS_Ctrl)
{
 50c:	cf 93       	push	r28
 50e:	df 93       	push	r29
 510:	ec 01       	movw	r28, r24
	if (cola_vacia(&cola_ctrl1))
 512:	8f e2       	ldi	r24, 0x2F	; 47
 514:	90 e2       	ldi	r25, 0x20	; 32
 516:	0e 94 83 04 	call	0x906	; 0x906 <cola_vacia>
 51a:	88 23       	and	r24, r24
 51c:	11 f0       	breq	.+4      	; 0x522 <ADS_BusqueColaLibre+0x16>
	{
		ADS_Ctrl->cola_activa = 1;
 51e:	81 e0       	ldi	r24, 0x01	; 1
 520:	07 c0       	rjmp	.+14     	; 0x530 <ADS_BusqueColaLibre+0x24>
	}
	else if(cola_vacia(&cola_ctrl2))
 522:	80 e0       	ldi	r24, 0x00	; 0
 524:	90 e2       	ldi	r25, 0x20	; 32
 526:	0e 94 83 04 	call	0x906	; 0x906 <cola_vacia>
 52a:	88 23       	and	r24, r24
 52c:	19 f0       	breq	.+6      	; 0x534 <ADS_BusqueColaLibre+0x28>
	{
		ADS_Ctrl->cola_activa = 2;
 52e:	82 e0       	ldi	r24, 0x02	; 2
 530:	88 8f       	std	Y+24, r24	; 0x18
 532:	01 c0       	rjmp	.+2      	; 0x536 <ADS_BusqueColaLibre+0x2a>
	}
	else
	{
		ADS_Ctrl->cola_activa = 0;
 534:	18 8e       	std	Y+24, r1	; 0x18
	}
}
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	08 95       	ret

0000053c <ADS_Adquiera>:
	while (!(ADS_Ctrl->banderas & ADS_BYTE_ENVIADO_bm));
	
}

void ADS_Adquiera(volatile ADS_Control *ADS_Ctrl)
{
 53c:	cf 93       	push	r28
 53e:	df 93       	push	r29
 540:	fc 01       	movw	r30, r24
	if (ADS_Ctrl->banderas & ADS_ADQUISICION_DETENIDA_bm)
 542:	80 81       	ld	r24, Z
 544:	84 fd       	sbrc	r24, 4
 546:	45 c0       	rjmp	.+138    	; 0x5d2 <ADS_Adquiera+0x96>
		return;
	
	switch(ADS_Ctrl->estado)
 548:	87 89       	ldd	r24, Z+23	; 0x17
 54a:	82 30       	cpi	r24, 0x02	; 2
 54c:	c9 f0       	breq	.+50     	; 0x580 <ADS_Adquiera+0x44>
 54e:	18 f4       	brcc	.+6      	; 0x556 <ADS_Adquiera+0x1a>
 550:	81 30       	cpi	r24, 0x01	; 1
 552:	31 f0       	breq	.+12     	; 0x560 <ADS_Adquiera+0x24>
 554:	3e c0       	rjmp	.+124    	; 0x5d2 <ADS_Adquiera+0x96>
 556:	83 30       	cpi	r24, 0x03	; 3
 558:	d1 f0       	breq	.+52     	; 0x58e <ADS_Adquiera+0x52>
 55a:	84 30       	cpi	r24, 0x04	; 4
 55c:	81 f1       	breq	.+96     	; 0x5be <ADS_Adquiera+0x82>
 55e:	39 c0       	rjmp	.+114    	; 0x5d2 <ADS_Adquiera+0x96>
	{
		case ADS_ESTADO_ESPEREDRDY:
			//Verifique que hayan datos listos
			if(!(PORTD.IN & PIN_ADS_DRDY_bm))
 560:	80 91 68 06 	lds	r24, 0x0668
 564:	85 fd       	sbrc	r24, 5
 566:	02 c0       	rjmp	.+4      	; 0x56c <ADS_Adquiera+0x30>
			{
				//Busque una cola libre para la adquisición
				ADS_Ctrl->estado = ADS_ESTADO_BUSQUECOLA;	
 568:	82 e0       	ldi	r24, 0x02	; 2
 56a:	32 c0       	rjmp	.+100    	; 0x5d0 <ADS_Adquiera+0x94>
			}
			else if(ADS_Ctrl->banderas & ADS_DETENGA_ADQUISICION_bm)
 56c:	80 81       	ld	r24, Z
 56e:	83 ff       	sbrs	r24, 3
 570:	30 c0       	rjmp	.+96     	; 0x5d2 <ADS_Adquiera+0x96>
			{
				//Detener la adquisición
				ADS_Ctrl->banderas |= ADS_ADQUISICION_DETENIDA_bm;
 572:	80 81       	ld	r24, Z
 574:	80 61       	ori	r24, 0x10	; 16
 576:	80 83       	st	Z, r24
					
				//Limpiar bandera de solicitud de detención
				ADS_Ctrl->banderas &= ~(ADS_DETENGA_ADQUISICION_bm);
 578:	80 81       	ld	r24, Z
 57a:	87 7f       	andi	r24, 0xF7	; 247
 57c:	80 83       	st	Z, r24
 57e:	29 c0       	rjmp	.+82     	; 0x5d2 <ADS_Adquiera+0x96>
 580:	ef 01       	movw	r28, r30
			}
		break;
			
		case ADS_ESTADO_BUSQUECOLA:
			ADS_BusqueColaLibre(ADS_Ctrl);
 582:	cf 01       	movw	r24, r30
 584:	0e 94 86 02 	call	0x50c	; 0x50c <ADS_BusqueColaLibre>
			//if (ADS_Ctrl->cola_activa)
			//{
				ADS_Ctrl->estado = ADS_ESTADO_EMPIECE_ADQUISICION;
 588:	83 e0       	ldi	r24, 0x03	; 3
 58a:	8f 8b       	std	Y+23, r24	; 0x17
			//}
		break;
 58c:	22 c0       	rjmp	.+68     	; 0x5d2 <ADS_Adquiera+0x96>
			
		case ADS_ESTADO_EMPIECE_ADQUISICION:
			//Active receptor USART
			USARTC1.CTRLB |= (USART_RXEN_bm);
 58e:	90 91 b4 08 	lds	r25, 0x08B4
 592:	90 61       	ori	r25, 0x10	; 16
 594:	90 93 b4 08 	sts	0x08B4, r25
				
			//Inicie interfaz
			PORTC.OUTCLR = PIN_ADS_CS_bm;
 598:	90 e1       	ldi	r25, 0x10	; 16
 59a:	90 93 46 06 	sts	0x0646, r25
				
			//Inicialice contadores de datos
			ADS_Ctrl->n_datos = 0;
 59e:	13 8a       	std	Z+19, r1	; 0x13
			ADS_Ctrl->n_datos_leidos = 0;
 5a0:	16 8a       	std	Z+22, r1	; 0x16
				
			//Siguiente estado
			ADS_Ctrl->estado = ADS_ESTADO_ADQUIRIENDO;
 5a2:	94 e0       	ldi	r25, 0x04	; 4
 5a4:	97 8b       	std	Z+23, r25	; 0x17
				
			//Modo recepción de datos
			ADS_Ctrl->modo_com = ADS_MODO_COM_RECIBIENDO_MUESTRA;
 5a6:	81 83       	std	Z+1, r24	; 0x01
			ADS_Ctrl->banderas &= ~(ADS_MUESTRA_RECIBIDA_bm);
 5a8:	80 81       	ld	r24, Z
 5aa:	8b 7f       	andi	r24, 0xFB	; 251
 5ac:	80 83       	st	Z, r24
				
			//Empiece la lectura
			USARTC1.DATA = 0x00;
 5ae:	10 92 b0 08 	sts	0x08B0, r1
				
			//Habilite interrupciones de recepción completa y DRE
			USARTC1.CTRLA |= ((3<<USART_RXCINTLVL_gp)|(3<<USART_DREINTLVL_gp));
 5b2:	80 91 b3 08 	lds	r24, 0x08B3
 5b6:	83 63       	ori	r24, 0x33	; 51
 5b8:	80 93 b3 08 	sts	0x08B3, r24
			
		break;
 5bc:	0a c0       	rjmp	.+20     	; 0x5d2 <ADS_Adquiera+0x96>
		
		case ADS_ESTADO_ADQUIRIENDO:
			if(ADS_Ctrl->banderas & ADS_MUESTRA_RECIBIDA_bm)
 5be:	80 81       	ld	r24, Z
 5c0:	82 ff       	sbrs	r24, 2
 5c2:	07 c0       	rjmp	.+14     	; 0x5d2 <ADS_Adquiera+0x96>
			{
				//Inhabilite el receptor
				USARTC1.CTRLB &= ~(USART_RXEN_bm);
 5c4:	80 91 b4 08 	lds	r24, 0x08B4
 5c8:	8f 7e       	andi	r24, 0xEF	; 239
 5ca:	80 93 b4 08 	sts	0x08B4, r24
				
				//Vuelva al estado inicial
				ADS_Ctrl->estado = ADS_ESTADO_ESPEREDRDY;
 5ce:	81 e0       	ldi	r24, 0x01	; 1
 5d0:	87 8b       	std	Z+23, r24	; 0x17
			}
		break;
		
	}
}
 5d2:	df 91       	pop	r29
 5d4:	cf 91       	pop	r28
 5d6:	08 95       	ret

000005d8 <__vector_30>:
	ADS_Ctrl->banderas |= ADS_DETENGA_ADQUISICION_bm;
}


ISR(USARTC1_TXC_vect)
{
 5d8:	1f 92       	push	r1
 5da:	0f 92       	push	r0
 5dc:	0f b6       	in	r0, 0x3f	; 63
 5de:	0f 92       	push	r0
 5e0:	11 24       	eor	r1, r1
 5e2:	8f 93       	push	r24
	switch (ADS_Ctrl.modo_com)
 5e4:	80 91 09 20 	lds	r24, 0x2009
 5e8:	81 30       	cpi	r24, 0x01	; 1
 5ea:	31 f0       	breq	.+12     	; 0x5f8 <__vector_30+0x20>
 5ec:	82 30       	cpi	r24, 0x02	; 2
 5ee:	49 f4       	brne	.+18     	; 0x602 <__vector_30+0x2a>
			ADS_Ctrl.banderas |= ADS_BYTE_ENVIADO_bm;
		break;
		
		//Enviando arreglo
		case ADS_MODO_COM_ENVIANDO_ARREGLO:
			ADS_Ctrl.banderas |= ADS_ARREGLO_ENVIADO_bm;
 5f0:	80 91 08 20 	lds	r24, 0x2008
 5f4:	82 60       	ori	r24, 0x02	; 2
 5f6:	03 c0       	rjmp	.+6      	; 0x5fe <__vector_30+0x26>
{
	switch (ADS_Ctrl.modo_com)
	{
		//Enviando byte
		case ADS_MODO_COM_ENVIANDO_BYTE:
			ADS_Ctrl.banderas |= ADS_BYTE_ENVIADO_bm;
 5f8:	80 91 08 20 	lds	r24, 0x2008
 5fc:	81 60       	ori	r24, 0x01	; 1
		break;
		
		//Enviando arreglo
		case ADS_MODO_COM_ENVIANDO_ARREGLO:
			ADS_Ctrl.banderas |= ADS_ARREGLO_ENVIADO_bm;
 5fe:	80 93 08 20 	sts	0x2008, r24
		break;		
	}
	
	//Apague las interrupciones por transmisión completa
	USARTC1.CTRLA &= ~(3<<USART_TXCINTLVL_gp);
 602:	80 91 b3 08 	lds	r24, 0x08B3
 606:	83 7f       	andi	r24, 0xF3	; 243
 608:	80 93 b3 08 	sts	0x08B3, r24
	
	//Finalice interface de datos
	PORTC.OUTSET = PIN_ADS_CS_bm;
 60c:	80 e1       	ldi	r24, 0x10	; 16
 60e:	80 93 45 06 	sts	0x0645, r24
}
 612:	8f 91       	pop	r24
 614:	0f 90       	pop	r0
 616:	0f be       	out	0x3f, r0	; 63
 618:	0f 90       	pop	r0
 61a:	1f 90       	pop	r1
 61c:	18 95       	reti

0000061e <__vector_29>:

ISR(USARTC1_DRE_vect)
{
 61e:	1f 92       	push	r1
 620:	0f 92       	push	r0
 622:	0f b6       	in	r0, 0x3f	; 63
 624:	0f 92       	push	r0
 626:	11 24       	eor	r1, r1
 628:	8f 93       	push	r24
 62a:	9f 93       	push	r25
 62c:	ef 93       	push	r30
 62e:	ff 93       	push	r31
	switch(ADS_Ctrl.modo_com)
 630:	80 91 09 20 	lds	r24, 0x2009
 634:	82 30       	cpi	r24, 0x02	; 2
 636:	19 f0       	breq	.+6      	; 0x63e <__vector_29+0x20>
 638:	83 30       	cpi	r24, 0x03	; 3
 63a:	a9 f0       	breq	.+42     	; 0x666 <__vector_29+0x48>
 63c:	25 c0       	rjmp	.+74     	; 0x688 <__vector_29+0x6a>
	{
		case ADS_MODO_COM_ENVIANDO_ARREGLO:
			//Aumente el contador de datos
			ADS_Ctrl.n_datos++;
 63e:	80 91 1b 20 	lds	r24, 0x201B
 642:	8f 5f       	subi	r24, 0xFF	; 255
 644:	80 93 1b 20 	sts	0x201B, r24
			
			//Si no hay más datos, inhabilite la interrupción de DRE
			if (ADS_Ctrl.n_datos == ADS_Ctrl.datos_max)
 648:	90 91 1b 20 	lds	r25, 0x201B
 64c:	80 91 1c 20 	lds	r24, 0x201C
 650:	98 17       	cp	r25, r24
 652:	91 f0       	breq	.+36     	; 0x678 <__vector_29+0x5a>
			{
				USARTC1.CTRLA &= ~(3<<USART_DREINTLVL_gp);
				break;
			}
			
			USARTC1.DATA = ADS_Ctrl.arreglo[ADS_Ctrl.n_datos];
 654:	e0 91 1b 20 	lds	r30, 0x201B
 658:	f0 e0       	ldi	r31, 0x00	; 0
 65a:	e8 5f       	subi	r30, 0xF8	; 248
 65c:	ff 4d       	sbci	r31, 0xDF	; 223
 65e:	82 81       	ldd	r24, Z+2	; 0x02
 660:	80 93 b0 08 	sts	0x08B0, r24
		
		break;
 664:	11 c0       	rjmp	.+34     	; 0x688 <__vector_29+0x6a>
		
		case ADS_MODO_COM_RECIBIENDO_MUESTRA:
			ADS_Ctrl.n_datos++;
 666:	80 91 1b 20 	lds	r24, 0x201B
 66a:	8f 5f       	subi	r24, 0xFF	; 255
 66c:	80 93 1b 20 	sts	0x201B, r24
			
			//Si no hay más datos, inhabilite la interrupción de DRE
			if (ADS_Ctrl.n_datos == 27)
 670:	80 91 1b 20 	lds	r24, 0x201B
 674:	8b 31       	cpi	r24, 0x1B	; 27
 676:	31 f4       	brne	.+12     	; 0x684 <__vector_29+0x66>
			{
				USARTC1.CTRLA &= ~(3<<USART_DREINTLVL_gp);
 678:	80 91 b3 08 	lds	r24, 0x08B3
 67c:	8c 7f       	andi	r24, 0xFC	; 252
 67e:	80 93 b3 08 	sts	0x08B3, r24
 682:	02 c0       	rjmp	.+4      	; 0x688 <__vector_29+0x6a>
			}
			else
			{
				//Solicite el siguiente dato
				USARTC1.DATA = 0x00;
 684:	10 92 b0 08 	sts	0x08B0, r1
			}
		break;
	}
}
 688:	ff 91       	pop	r31
 68a:	ef 91       	pop	r30
 68c:	9f 91       	pop	r25
 68e:	8f 91       	pop	r24
 690:	0f 90       	pop	r0
 692:	0f be       	out	0x3f, r0	; 63
 694:	0f 90       	pop	r0
 696:	1f 90       	pop	r1
 698:	18 95       	reti

0000069a <__vector_28>:

ISR(USARTC1_RXC_vect)
{
 69a:	1f 92       	push	r1
 69c:	0f 92       	push	r0
 69e:	0f b6       	in	r0, 0x3f	; 63
 6a0:	0f 92       	push	r0
 6a2:	11 24       	eor	r1, r1
 6a4:	2f 93       	push	r18
 6a6:	3f 93       	push	r19
 6a8:	4f 93       	push	r20
 6aa:	5f 93       	push	r21
 6ac:	6f 93       	push	r22
 6ae:	7f 93       	push	r23
 6b0:	8f 93       	push	r24
 6b2:	9f 93       	push	r25
 6b4:	af 93       	push	r26
 6b6:	bf 93       	push	r27
 6b8:	ef 93       	push	r30
 6ba:	ff 93       	push	r31
	//Lectura de datos
	ADS_Ctrl.dato = USARTC1.DATA;
 6bc:	80 91 b0 08 	lds	r24, 0x08B0
 6c0:	80 93 1d 20 	sts	0x201D, r24
		
	//Inserción de datos en las colas
	if(ADS_Ctrl.cola_activa == 1)
 6c4:	80 91 20 20 	lds	r24, 0x2020
	{
		//char letra=0x41;
		cola_inserte(&cola_ctrl1,ADS_Ctrl.dato);//cambiar dato por char
 6c8:	60 91 1d 20 	lds	r22, 0x201D
{
	//Lectura de datos
	ADS_Ctrl.dato = USARTC1.DATA;
		
	//Inserción de datos en las colas
	if(ADS_Ctrl.cola_activa == 1)
 6cc:	81 30       	cpi	r24, 0x01	; 1
 6ce:	19 f4       	brne	.+6      	; 0x6d6 <__vector_28+0x3c>
	{
		//char letra=0x41;
		cola_inserte(&cola_ctrl1,ADS_Ctrl.dato);//cambiar dato por char
 6d0:	8f e2       	ldi	r24, 0x2F	; 47
 6d2:	90 e2       	ldi	r25, 0x20	; 32
 6d4:	02 c0       	rjmp	.+4      	; 0x6da <__vector_28+0x40>
		//}
	}
	else
	{
				//char letra=0x41;
				cola_inserte(&cola_ctrl2,ADS_Ctrl.dato);//cambiar dato por char
 6d6:	80 e0       	ldi	r24, 0x00	; 0
 6d8:	90 e2       	ldi	r25, 0x20	; 32
 6da:	0e 94 49 04 	call	0x892	; 0x892 <cola_inserte>
				//}

	}
	
	//Incremente contador de datos
	ADS_Ctrl.n_datos_leidos++;
 6de:	80 91 1e 20 	lds	r24, 0x201E
 6e2:	8f 5f       	subi	r24, 0xFF	; 255
 6e4:	80 93 1e 20 	sts	0x201E, r24
	
	if(ADS_Ctrl.n_datos_leidos == 27)
 6e8:	80 91 1e 20 	lds	r24, 0x201E
 6ec:	8b 31       	cpi	r24, 0x1B	; 27
 6ee:	69 f4       	brne	.+26     	; 0x70a <__vector_28+0x70>
	{
		//Inhabilite interrupción
		USARTC1.CTRLA &= ~(3<<USART_RXCINTLVL_gp);
 6f0:	80 91 b3 08 	lds	r24, 0x08B3
 6f4:	8f 7c       	andi	r24, 0xCF	; 207
 6f6:	80 93 b3 08 	sts	0x08B3, r24
		
		//Fin de recepción de la muestra
		ADS_Ctrl.banderas |= ADS_MUESTRA_RECIBIDA_bm;
 6fa:	80 91 08 20 	lds	r24, 0x2008
 6fe:	84 60       	ori	r24, 0x04	; 4
 700:	80 93 08 20 	sts	0x2008, r24
		
		//Finalice la interfaz
		PORTC.OUTSET = PIN_ADS_CS_bm;	
 704:	80 e1       	ldi	r24, 0x10	; 16
 706:	80 93 45 06 	sts	0x0645, r24
	}
 70a:	ff 91       	pop	r31
 70c:	ef 91       	pop	r30
 70e:	bf 91       	pop	r27
 710:	af 91       	pop	r26
 712:	9f 91       	pop	r25
 714:	8f 91       	pop	r24
 716:	7f 91       	pop	r23
 718:	6f 91       	pop	r22
 71a:	5f 91       	pop	r21
 71c:	4f 91       	pop	r20
 71e:	3f 91       	pop	r19
 720:	2f 91       	pop	r18
 722:	0f 90       	pop	r0
 724:	0f be       	out	0x3f, r0	; 63
 726:	0f 90       	pop	r0
 728:	1f 90       	pop	r1
 72a:	18 95       	reti

0000072c <setupSerial>:
volatile extern cola_control cola_ctrl1;
volatile extern cola_control cola_ctrl2;

void setupSerial()
{	
	PORTC_DIRSET=PIN3_bm;
 72c:	88 e0       	ldi	r24, 0x08	; 8
 72e:	80 93 41 06 	sts	0x0641, r24
	PORTC_DIRCLR=PIN2_bm;
 732:	84 e0       	ldi	r24, 0x04	; 4
 734:	80 93 42 06 	sts	0x0642, r24
	
	USARTC0_BAUDCTRLA = 123;//123;//53; 
 738:	8b e7       	ldi	r24, 0x7B	; 123
 73a:	80 93 a6 08 	sts	0x08A6, r24
	USARTC0_BAUDCTRLB = 0b00001100<<4; //Just to be sure that BSCALE is -4//0b00000110<<4 //0b11000000
 73e:	80 ec       	ldi	r24, 0xC0	; 192
 740:	80 93 a7 08 	sts	0x08A7, r24
	
	
	//Disable interrupts, just for safety
	USARTC0_CTRLA = USART_INTERRUPT;
 744:	10 92 a3 08 	sts	0x08A3, r1
	//8 data bits, no parity and 1 stop bit
	USARTC0_CTRLC = USART_CHSIZE_8BIT_gc;
 748:	83 e0       	ldi	r24, 0x03	; 3
 74a:	80 93 a5 08 	sts	0x08A5, r24
	
	//Enable receive and transmit
	USARTC0_CTRLB = USART_TXEN_bm | USART_RXEN_bm; // And enable high speed mode
 74e:	88 e1       	ldi	r24, 0x18	; 24
 750:	80 93 a4 08 	sts	0x08A4, r24
 754:	08 95       	ret

00000756 <BT_Init>:
		sendChar(*text++);
	}
}

void BT_Init(volatile BT_Control *BT_ctrl)
{
 756:	cf 93       	push	r28
 758:	df 93       	push	r29
 75a:	ec 01       	movw	r28, r24
	setupSerial();
 75c:	0e 94 96 03 	call	0x72c	; 0x72c <setupSerial>
	BT_ctrl->estado = BT_ESTADO_TX_HAYDATOS;
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	89 87       	std	Y+9, r24	; 0x09
	
}
 764:	df 91       	pop	r29
 766:	cf 91       	pop	r28
 768:	08 95       	ret

0000076a <BT_Transmitir>:

void BT_Transmitir(volatile BT_Control *BT_ctrl)
{
 76a:	1f 93       	push	r17
 76c:	cf 93       	push	r28
 76e:	df 93       	push	r29
 770:	ec 01       	movw	r28, r24
	Enviar datos
	esperando datos
	                                                                     */
	/************************************************************************/

	switch (BT_ctrl->estado)
 772:	19 85       	ldd	r17, Y+9	; 0x09
 774:	11 30       	cpi	r17, 0x01	; 1
 776:	19 f0       	breq	.+6      	; 0x77e <BT_Transmitir+0x14>
 778:	13 30       	cpi	r17, 0x03	; 3
 77a:	f9 f0       	breq	.+62     	; 0x7ba <BT_Transmitir+0x50>
 77c:	26 c0       	rjmp	.+76     	; 0x7ca <BT_Transmitir+0x60>
	{
		case BT_ESTADO_TX_HAYDATOS:
			
			if (cola_llena(&cola_ctrl1))
 77e:	8f e2       	ldi	r24, 0x2F	; 47
 780:	90 e2       	ldi	r25, 0x20	; 32
 782:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <cola_llena>
 786:	81 11       	cpse	r24, r1
 788:	06 c0       	rjmp	.+12     	; 0x796 <BT_Transmitir+0x2c>
			{
				BT_ctrl->cola_activa = 1;
				BT_ctrl->banderas |= BT_HAYDATOS_bm;
			}
			else if (cola_llena(&cola_ctrl2))
 78a:	80 e0       	ldi	r24, 0x00	; 0
 78c:	90 e2       	ldi	r25, 0x20	; 32
 78e:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <cola_llena>
 792:	88 23       	and	r24, r24
 794:	21 f0       	breq	.+8      	; 0x79e <BT_Transmitir+0x34>
			{
				BT_ctrl->cola_activa = 1;
 796:	1a 87       	std	Y+10, r17	; 0x0a
				BT_ctrl->banderas |= BT_HAYDATOS_bm;
 798:	88 81       	ld	r24, Y
 79a:	80 62       	ori	r24, 0x20	; 32
 79c:	88 83       	st	Y, r24
			}
			
			if (BT_ctrl->banderas & BT_HAYDATOS_bm)
 79e:	88 81       	ld	r24, Y
 7a0:	85 ff       	sbrs	r24, 5
 7a2:	13 c0       	rjmp	.+38     	; 0x7ca <BT_Transmitir+0x60>
			{
				BT_ctrl->estado = BT_ESTADO_TX_CARGANDOPAYLOAD;
 7a4:	83 e0       	ldi	r24, 0x03	; 3
 7a6:	89 87       	std	Y+9, r24	; 0x09
				//Indicar que se empezó la transmisión
				BT_ctrl->banderas |= BT_TRANSMITIENDO_bm;
 7a8:	88 81       	ld	r24, Y
 7aa:	80 61       	ori	r24, 0x10	; 16
 7ac:	88 83       	st	Y, r24
				//habilite interrupciones de TXC y de DRE
				USARTC0.CTRLA |= ((3<<USART_TXCINTLVL_gp)|(3<<USART_DREINTLVL_gp));
 7ae:	80 91 a3 08 	lds	r24, 0x08A3
 7b2:	8f 60       	ori	r24, 0x0F	; 15
 7b4:	80 93 a3 08 	sts	0x08A3, r24
 7b8:	08 c0       	rjmp	.+16     	; 0x7ca <BT_Transmitir+0x60>

		break;
		
		case BT_ESTADO_TX_CARGANDOPAYLOAD:
			
			if (!(BT_ctrl->banderas & BT_TRANSMITIENDO_bm))
 7ba:	88 81       	ld	r24, Y
 7bc:	84 fd       	sbrc	r24, 4
 7be:	05 c0       	rjmp	.+10     	; 0x7ca <BT_Transmitir+0x60>
			{
				BT_ctrl->banderas &= (~BT_HAYDATOS_bm);
 7c0:	88 81       	ld	r24, Y
 7c2:	8f 7d       	andi	r24, 0xDF	; 223
 7c4:	88 83       	st	Y, r24
				BT_ctrl->estado = BT_ESTADO_TX_HAYDATOS;			
 7c6:	81 e0       	ldi	r24, 0x01	; 1
 7c8:	89 87       	std	Y+9, r24	; 0x09
			}
		break;	
	}
}
 7ca:	df 91       	pop	r29
 7cc:	cf 91       	pop	r28
 7ce:	1f 91       	pop	r17
 7d0:	08 95       	ret

000007d2 <__vector_26>:


ISR(USARTC0_DRE_vect)
{
 7d2:	1f 92       	push	r1
 7d4:	0f 92       	push	r0
 7d6:	0f b6       	in	r0, 0x3f	; 63
 7d8:	0f 92       	push	r0
 7da:	11 24       	eor	r1, r1
 7dc:	2f 93       	push	r18
 7de:	3f 93       	push	r19
 7e0:	4f 93       	push	r20
 7e2:	5f 93       	push	r21
 7e4:	6f 93       	push	r22
 7e6:	7f 93       	push	r23
 7e8:	8f 93       	push	r24
 7ea:	9f 93       	push	r25
 7ec:	af 93       	push	r26
 7ee:	bf 93       	push	r27
 7f0:	ef 93       	push	r30
 7f2:	ff 93       	push	r31
 7f4:	cf 93       	push	r28
 7f6:	df 93       	push	r29
 7f8:	1f 92       	push	r1
 7fa:	cd b7       	in	r28, 0x3d	; 61
 7fc:	de b7       	in	r29, 0x3e	; 62
	char dato;
	if (BT_ctrl.cola_activa == 1)
 7fe:	80 91 2b 20 	lds	r24, 0x202B
	{
		if (cola_retire(&cola_ctrl1,&dato))
 802:	be 01       	movw	r22, r28
 804:	6f 5f       	subi	r22, 0xFF	; 255
 806:	7f 4f       	sbci	r23, 0xFF	; 255


ISR(USARTC0_DRE_vect)
{
	char dato;
	if (BT_ctrl.cola_activa == 1)
 808:	81 30       	cpi	r24, 0x01	; 1
 80a:	19 f4       	brne	.+6      	; 0x812 <__vector_26+0x40>
	{
		if (cola_retire(&cola_ctrl1,&dato))
 80c:	8f e2       	ldi	r24, 0x2F	; 47
 80e:	90 e2       	ldi	r25, 0x20	; 32
 810:	02 c0       	rjmp	.+4      	; 0x816 <__vector_26+0x44>
			USARTC0.CTRLA &= ~(3<<USART_DREINTLVL_gp);
		}
	}
	else
	{
		if (cola_retire(&cola_ctrl2,&dato))
 812:	80 e0       	ldi	r24, 0x00	; 0
 814:	90 e2       	ldi	r25, 0x20	; 32
 816:	0e 94 63 04 	call	0x8c6	; 0x8c6 <cola_retire>
 81a:	88 23       	and	r24, r24
 81c:	21 f0       	breq	.+8      	; 0x826 <__vector_26+0x54>
		{
			USARTC0.DATA = dato;
 81e:	89 81       	ldd	r24, Y+1	; 0x01
 820:	80 93 a0 08 	sts	0x08A0, r24
 824:	05 c0       	rjmp	.+10     	; 0x830 <__vector_26+0x5e>
			
		}
		else
		{
			//Apago interrupción
			USARTC0.CTRLA &= ~(3<<USART_DREINTLVL_gp);
 826:	80 91 a3 08 	lds	r24, 0x08A3
 82a:	8c 7f       	andi	r24, 0xFC	; 252
 82c:	80 93 a3 08 	sts	0x08A3, r24
		}
	}
}
 830:	0f 90       	pop	r0
 832:	df 91       	pop	r29
 834:	cf 91       	pop	r28
 836:	ff 91       	pop	r31
 838:	ef 91       	pop	r30
 83a:	bf 91       	pop	r27
 83c:	af 91       	pop	r26
 83e:	9f 91       	pop	r25
 840:	8f 91       	pop	r24
 842:	7f 91       	pop	r23
 844:	6f 91       	pop	r22
 846:	5f 91       	pop	r21
 848:	4f 91       	pop	r20
 84a:	3f 91       	pop	r19
 84c:	2f 91       	pop	r18
 84e:	0f 90       	pop	r0
 850:	0f be       	out	0x3f, r0	; 63
 852:	0f 90       	pop	r0
 854:	1f 90       	pop	r1
 856:	18 95       	reti

00000858 <__vector_27>:

ISR(USARTC0_TXC_vect)
{
 858:	1f 92       	push	r1
 85a:	0f 92       	push	r0
 85c:	0f b6       	in	r0, 0x3f	; 63
 85e:	0f 92       	push	r0
 860:	11 24       	eor	r1, r1
 862:	8f 93       	push	r24
 864:	ef 93       	push	r30
 866:	ff 93       	push	r31
	//Indicar que finalizó transmisión de una muestra
	BT_ctrl.banderas &= ~(BT_TRANSMITIENDO_bm);
 868:	e1 e2       	ldi	r30, 0x21	; 33
 86a:	f0 e2       	ldi	r31, 0x20	; 32
 86c:	80 81       	ld	r24, Z
 86e:	8f 7e       	andi	r24, 0xEF	; 239
 870:	80 83       	st	Z, r24
 872:	ff 91       	pop	r31
 874:	ef 91       	pop	r30
 876:	8f 91       	pop	r24
 878:	0f 90       	pop	r0
 87a:	0f be       	out	0x3f, r0	; 63
 87c:	0f 90       	pop	r0
 87e:	1f 90       	pop	r1
 880:	18 95       	reti

00000882 <cola_init>:
#include "cola.h"

void cola_init(volatile cola_control *cola_ctrl, 
				char max, 
				char *cola)
{
 882:	fc 01       	movw	r30, r24
	cola_ctrl->cont_in = 0;
 884:	10 82       	st	Z, r1
	cola_ctrl->cont_out = 0;
 886:	11 82       	std	Z+1, r1	; 0x01
	cola_ctrl->cont_datos = 0;
 888:	12 82       	std	Z+2, r1	; 0x02
	cola_ctrl->max = max;
 88a:	63 83       	std	Z+3, r22	; 0x03
	cola_ctrl->cola = cola;
 88c:	44 83       	std	Z+4, r20	; 0x04
 88e:	55 83       	std	Z+5, r21	; 0x05
 890:	08 95       	ret

00000892 <cola_inserte>:
}

char cola_inserte(volatile cola_control *cola_ctrl, 
				char dato)
{
 892:	fc 01       	movw	r30, r24
	if (cola_ctrl->cont_datos == cola_ctrl->max)
 894:	92 81       	ldd	r25, Z+2	; 0x02
 896:	83 81       	ldd	r24, Z+3	; 0x03
 898:	98 17       	cp	r25, r24
 89a:	99 f0       	breq	.+38     	; 0x8c2 <cola_inserte+0x30>
		return(0);
	
	cola_ctrl->cola[cola_ctrl->cont_in] = dato;
 89c:	a4 81       	ldd	r26, Z+4	; 0x04
 89e:	b5 81       	ldd	r27, Z+5	; 0x05
 8a0:	80 81       	ld	r24, Z
 8a2:	a8 0f       	add	r26, r24
 8a4:	b1 1d       	adc	r27, r1
 8a6:	6c 93       	st	X, r22
	(cola_ctrl->cont_in)++;
 8a8:	80 81       	ld	r24, Z
 8aa:	8f 5f       	subi	r24, 0xFF	; 255
 8ac:	80 83       	st	Z, r24
	
	if (cola_ctrl->cont_in == cola_ctrl->max)
 8ae:	90 81       	ld	r25, Z
 8b0:	83 81       	ldd	r24, Z+3	; 0x03
 8b2:	98 13       	cpse	r25, r24
 8b4:	01 c0       	rjmp	.+2      	; 0x8b8 <cola_inserte+0x26>
		cola_ctrl->cont_in = 0;
 8b6:	10 82       	st	Z, r1
		
	(cola_ctrl->cont_datos)++;
 8b8:	82 81       	ldd	r24, Z+2	; 0x02
 8ba:	8f 5f       	subi	r24, 0xFF	; 255
 8bc:	82 83       	std	Z+2, r24	; 0x02
	return(1);
 8be:	81 e0       	ldi	r24, 0x01	; 1
 8c0:	08 95       	ret

char cola_inserte(volatile cola_control *cola_ctrl, 
				char dato)
{
	if (cola_ctrl->cont_datos == cola_ctrl->max)
		return(0);
 8c2:	80 e0       	ldi	r24, 0x00	; 0
	if (cola_ctrl->cont_in == cola_ctrl->max)
		cola_ctrl->cont_in = 0;
		
	(cola_ctrl->cont_datos)++;
	return(1);
}
 8c4:	08 95       	ret

000008c6 <cola_retire>:

char cola_retire(volatile cola_control *cola_ctrl, 
				char *dato)
{
 8c6:	fc 01       	movw	r30, r24
	if(!(cola_ctrl->cont_datos))
 8c8:	82 81       	ldd	r24, Z+2	; 0x02
 8ca:	88 23       	and	r24, r24
 8cc:	a1 f0       	breq	.+40     	; 0x8f6 <cola_retire+0x30>
		return (0);
		
	*dato = cola_ctrl->cola[cola_ctrl->cont_out];
 8ce:	a4 81       	ldd	r26, Z+4	; 0x04
 8d0:	b5 81       	ldd	r27, Z+5	; 0x05
 8d2:	81 81       	ldd	r24, Z+1	; 0x01
 8d4:	a8 0f       	add	r26, r24
 8d6:	b1 1d       	adc	r27, r1
 8d8:	8c 91       	ld	r24, X
 8da:	db 01       	movw	r26, r22
 8dc:	8c 93       	st	X, r24
	(cola_ctrl->cont_out)++;
 8de:	81 81       	ldd	r24, Z+1	; 0x01
 8e0:	8f 5f       	subi	r24, 0xFF	; 255
 8e2:	81 83       	std	Z+1, r24	; 0x01
	
	if(cola_ctrl->cont_out == cola_ctrl->max)
 8e4:	91 81       	ldd	r25, Z+1	; 0x01
 8e6:	83 81       	ldd	r24, Z+3	; 0x03
 8e8:	98 13       	cpse	r25, r24
 8ea:	01 c0       	rjmp	.+2      	; 0x8ee <cola_retire+0x28>
		cola_ctrl->cont_out = 0;
 8ec:	11 82       	std	Z+1, r1	; 0x01
	
	(cola_ctrl->cont_datos)--;
 8ee:	82 81       	ldd	r24, Z+2	; 0x02
 8f0:	81 50       	subi	r24, 0x01	; 1
 8f2:	82 83       	std	Z+2, r24	; 0x02
	return(1);
 8f4:	81 e0       	ldi	r24, 0x01	; 1
}
 8f6:	08 95       	ret

000008f8 <cola_llena>:

char cola_llena(volatile cola_control *cola_ctrl)
{
	if (cola_ctrl->cont_datos == cola_ctrl->max)
 8f8:	fc 01       	movw	r30, r24
 8fa:	22 81       	ldd	r18, Z+2	; 0x02
 8fc:	93 81       	ldd	r25, Z+3	; 0x03
 8fe:	81 e0       	ldi	r24, 0x01	; 1
 900:	29 13       	cpse	r18, r25
 902:	80 e0       	ldi	r24, 0x00	; 0
	}		
	else
	{
		return(0);	
	}	
}
 904:	08 95       	ret

00000906 <cola_vacia>:

char cola_vacia(volatile cola_control *cola_ctrl)
{
	if(!(cola_ctrl->cont_datos))
 906:	fc 01       	movw	r30, r24
 908:	92 81       	ldd	r25, Z+2	; 0x02
 90a:	81 e0       	ldi	r24, 0x01	; 1
 90c:	91 11       	cpse	r25, r1
 90e:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		return(0);	
	}
	
 910:	08 95       	ret

00000912 <PW_init>:

extern volatile to_tcc0_delays_control to_c0_ctrl;

void PW_init(volatile PW_Control *PW_Ctrl,
			char Sleep_mode)
{
 912:	dc 01       	movw	r26, r24
	//Interrupciones tipo 0 habilitadas para el puerto B
	PORTB.INTCTRL |= (3<<PORT_INT0LVL_gp);
 914:	e0 e2       	ldi	r30, 0x20	; 32
 916:	f6 e0       	ldi	r31, 0x06	; 6
 918:	91 85       	ldd	r25, Z+9	; 0x09
 91a:	93 60       	ori	r25, 0x03	; 3
 91c:	91 87       	std	Z+9, r25	; 0x09
	PORTB.INT0MASK |= PW_PUSHBUTTON_bm;
 91e:	92 85       	ldd	r25, Z+10	; 0x0a
 920:	94 60       	ori	r25, 0x04	; 4
 922:	92 87       	std	Z+10, r25	; 0x0a
	//Sense Rising edge
	PORTB.PIN2CTRL |= 0b00000001;
 924:	92 89       	ldd	r25, Z+18	; 0x12
 926:	91 60       	ori	r25, 0x01	; 1
 928:	92 8b       	std	Z+18, r25	; 0x12
		
	//Indique estado en que quederá el dispositivo
	PW_Ctrl->modo = PW_MODO_SLEEP;
 92a:	81 e0       	ldi	r24, 0x01	; 1
 92c:	8c 93       	st	X, r24
	//Empiece en modo sleep;
	//Configure el modo de ahorro de energía
	SLEEP.CTRL |= Sleep_mode;	
 92e:	e8 e4       	ldi	r30, 0x48	; 72
 930:	f0 e0       	ldi	r31, 0x00	; 0
 932:	80 81       	ld	r24, Z
 934:	68 2b       	or	r22, r24
 936:	60 83       	st	Z, r22
	//Habilite el sleep;
	sleep_enable();
 938:	80 81       	ld	r24, Z
 93a:	81 60       	ori	r24, 0x01	; 1
 93c:	80 83       	st	Z, r24
	//INTERRUPCIONES DEBEN ESTAR ENCENDIDAS
	//vaya a modo sleep;
	sleep_cpu();
 93e:	88 95       	sleep
 940:	08 95       	ret

00000942 <__vector_34>:
}


ISR(PORTB_INT0_vect)
{
 942:	1f 92       	push	r1
 944:	0f 92       	push	r0
 946:	0f b6       	in	r0, 0x3f	; 63
 948:	0f 92       	push	r0
 94a:	11 24       	eor	r1, r1
 94c:	2f 93       	push	r18
 94e:	3f 93       	push	r19
 950:	4f 93       	push	r20
 952:	5f 93       	push	r21
 954:	6f 93       	push	r22
 956:	7f 93       	push	r23
 958:	8f 93       	push	r24
 95a:	9f 93       	push	r25
 95c:	af 93       	push	r26
 95e:	bf 93       	push	r27
 960:	ef 93       	push	r30
 962:	ff 93       	push	r31
	//Anti-rebote:
	//Inhabilite las interrupciones del puerto
	PORTB.INTCTRL &= ~(3<<PORT_INT0LVL_gp);
 964:	80 91 29 06 	lds	r24, 0x0629
 968:	8c 7f       	andi	r24, 0xFC	; 252
 96a:	80 93 29 06 	sts	0x0629, r24
	To_tcc0_InitTo(&to_c0_ctrl,0x1e,0x84,7);
 96e:	27 e0       	ldi	r18, 0x07	; 7
 970:	44 e8       	ldi	r20, 0x84	; 132
 972:	6e e1       	ldi	r22, 0x1E	; 30
 974:	86 e0       	ldi	r24, 0x06	; 6
 976:	90 e2       	ldi	r25, 0x20	; 32
 978:	0e 94 28 05 	call	0xa50	; 0xa50 <To_tcc0_InitTo>
	
		
	switch(PW_Ctrl.modo)
 97c:	80 91 2d 20 	lds	r24, 0x202D
 980:	81 30       	cpi	r24, 0x01	; 1
 982:	79 f0       	breq	.+30     	; 0x9a2 <__vector_34+0x60>
 984:	82 30       	cpi	r24, 0x02	; 2
 986:	a9 f4       	brne	.+42     	; 0x9b2 <__vector_34+0x70>
			PW_Ctrl.modo = PW_MODO_ACTIVO;
		break;
		
		//Debe detener Adquisiciones y dormir
		case PW_MODO_ACTIVO:
			wdt_enable(WDTO_15MS);
 988:	93 e0       	ldi	r25, 0x03	; 3
 98a:	88 ed       	ldi	r24, 0xD8	; 216
 98c:	08 b6       	in	r0, 0x38	; 56
 98e:	18 be       	out	0x38, r1	; 56
 990:	84 bf       	out	0x34, r24	; 52
 992:	90 93 80 00 	sts	0x0080, r25
 996:	80 91 82 00 	lds	r24, 0x0082
 99a:	81 fd       	sbrc	r24, 1
 99c:	fc cf       	rjmp	.-8      	; 0x996 <__vector_34+0x54>
 99e:	08 be       	out	0x38, r0	; 56
		break;
 9a0:	08 c0       	rjmp	.+16     	; 0x9b2 <__vector_34+0x70>
		
	switch(PW_Ctrl.modo)
	{
		//Debe despertar
		case PW_MODO_SLEEP:
			sleep_disable();
 9a2:	80 91 48 00 	lds	r24, 0x0048
 9a6:	8e 7f       	andi	r24, 0xFE	; 254
 9a8:	80 93 48 00 	sts	0x0048, r24
			PW_Ctrl.modo = PW_MODO_ACTIVO;
 9ac:	82 e0       	ldi	r24, 0x02	; 2
 9ae:	80 93 2d 20 	sts	0x202D, r24
		//Debe detener Adquisiciones y dormir
		case PW_MODO_ACTIVO:
			wdt_enable(WDTO_15MS);
		break;
	}
 9b2:	ff 91       	pop	r31
 9b4:	ef 91       	pop	r30
 9b6:	bf 91       	pop	r27
 9b8:	af 91       	pop	r26
 9ba:	9f 91       	pop	r25
 9bc:	8f 91       	pop	r24
 9be:	7f 91       	pop	r23
 9c0:	6f 91       	pop	r22
 9c2:	5f 91       	pop	r21
 9c4:	4f 91       	pop	r20
 9c6:	3f 91       	pop	r19
 9c8:	2f 91       	pop	r18
 9ca:	0f 90       	pop	r0
 9cc:	0f be       	out	0x3f, r0	; 63
 9ce:	0f 90       	pop	r0
 9d0:	1f 90       	pop	r1
 9d2:	18 95       	reti

000009d4 <Init32MHz>:
#include "FuncUtiles.h"

//Habilita oscilador interno de 32MHz
void Init32MHz()
{
	OSC.CTRL = OSC_RC32MEN_bm;       // enable 32MHz oscillator
 9d4:	82 e0       	ldi	r24, 0x02	; 2
 9d6:	80 93 50 00 	sts	0x0050, r24
    while(!(OSC.STATUS & OSC_RC32MRDY_bm)); // wait for oscillator to be ready
 9da:	80 91 51 00 	lds	r24, 0x0051
 9de:	81 ff       	sbrs	r24, 1
 9e0:	fc cf       	rjmp	.-8      	; 0x9da <Init32MHz+0x6>
    CCP = CCP_IOREG_gc;              // disable register security for clock update
 9e2:	88 ed       	ldi	r24, 0xD8	; 216
 9e4:	84 bf       	out	0x34, r24	; 52
    CLK.CTRL = CLK_SCLKSEL_RC32M_gc; // switch to 32MHz clock
 9e6:	81 e0       	ldi	r24, 0x01	; 1
 9e8:	80 93 40 00 	sts	0x0040, r24
	OSC.CTRL &=(~OSC_RC2MEN_bm); 
 9ec:	80 91 50 00 	lds	r24, 0x0050
 9f0:	8e 7f       	andi	r24, 0xFE	; 254
 9f2:	80 93 50 00 	sts	0x0050, r24
 9f6:	08 95       	ret

000009f8 <HabiliteInt>:
}

//Habilita interrupciones del nivel seleccionado
void HabiliteInt(char nivel)
{
	PMIC.CTRL |= nivel;
 9f8:	e0 ea       	ldi	r30, 0xA0	; 160
 9fa:	f0 e0       	ldi	r31, 0x00	; 0
 9fc:	92 81       	ldd	r25, Z+2	; 0x02
 9fe:	89 2b       	or	r24, r25
 a00:	82 83       	std	Z+2, r24	; 0x02
 a02:	08 95       	ret

00000a04 <__vector_14>:
#include <avr/interrupt.h>

extern to_tcc0_delays_control to_c0_ctrl;

ISR(TCC0_OVF_vect)
{
 a04:	1f 92       	push	r1
 a06:	0f 92       	push	r0
 a08:	0f b6       	in	r0, 0x3f	; 63
 a0a:	0f 92       	push	r0
 a0c:	11 24       	eor	r1, r1
 a0e:	8f 93       	push	r24
 a10:	ef 93       	push	r30
 a12:	ff 93       	push	r31
	TCC0.INTCTRLA &= ~(3); //deshabilite interrupciones de tcc0
 a14:	e0 e0       	ldi	r30, 0x00	; 0
 a16:	f8 e0       	ldi	r31, 0x08	; 8
 a18:	86 81       	ldd	r24, Z+6	; 0x06
 a1a:	8c 7f       	andi	r24, 0xFC	; 252
 a1c:	86 83       	std	Z+6, r24	; 0x06
	TCC0.CTRLA = 0; //detenga el timer
 a1e:	10 82       	st	Z, r1
	TCC0.CTRLFSET = (3 <<3); //reinicie el contador
 a20:	88 e1       	ldi	r24, 0x18	; 24
 a22:	81 87       	std	Z+9, r24	; 0x09
	to_c0_ctrl.banderas = TO_TCC0_FIN_bm; //indique que hubo un fin de conteo
 a24:	82 e0       	ldi	r24, 0x02	; 2
 a26:	80 93 06 20 	sts	0x2006, r24

	//Limpie bandera del puerto B para interrupciones del pulsador
	PORTB.INTFLAGS |= 0x01;	
 a2a:	e0 e2       	ldi	r30, 0x20	; 32
 a2c:	f6 e0       	ldi	r31, 0x06	; 6
 a2e:	84 85       	ldd	r24, Z+12	; 0x0c
 a30:	81 60       	ori	r24, 0x01	; 1
 a32:	84 87       	std	Z+12, r24	; 0x0c
	//Habilite interrupciones del puerto B para el pulsador
	PORTB.INTCTRL |= (3<<PORT_INT0LVL_gp);
 a34:	81 85       	ldd	r24, Z+9	; 0x09
 a36:	83 60       	ori	r24, 0x03	; 3
 a38:	81 87       	std	Z+9, r24	; 0x09
	
}
 a3a:	ff 91       	pop	r31
 a3c:	ef 91       	pop	r30
 a3e:	8f 91       	pop	r24
 a40:	0f 90       	pop	r0
 a42:	0f be       	out	0x3f, r0	; 63
 a44:	0f 90       	pop	r0
 a46:	1f 90       	pop	r1
 a48:	18 95       	reti

00000a4a <To_tcc0_Init>:

void To_tcc0_Init(to_tcc0_delays_control *to_ctrl)
{
	to_ctrl->banderas = 0;
 a4a:	fc 01       	movw	r30, r24
 a4c:	10 82       	st	Z, r1
 a4e:	08 95       	ret

00000a50 <To_tcc0_InitTo>:

void To_tcc0_InitTo(to_tcc0_delays_control *to_ctrl,
					char perh,
					char perl,
					char presc)
{
 a50:	fc 01       	movw	r30, r24
	if (to_ctrl->banderas & TO_TCC0_ACTIVO_bm)
 a52:	80 81       	ld	r24, Z
 a54:	80 ff       	sbrs	r24, 0
 a56:	02 c0       	rjmp	.+4      	; 0xa5c <To_tcc0_InitTo+0xc>
		to_ctrl->banderas |= TO_TCC0_OVR_bm; //Sobreescritura, sin reinicio
 a58:	84 60       	ori	r24, 0x04	; 4
 a5a:	80 83       	st	Z, r24
	
	to_ctrl->banderas |= TO_TCC0_ACTIVO_bm;	
	to_ctrl->banderas &= ~(TO_TCC0_FIN_bm);
 a5c:	90 81       	ld	r25, Z
 a5e:	9d 7f       	andi	r25, 0xFD	; 253
 a60:	91 60       	ori	r25, 0x01	; 1
 a62:	90 83       	st	Z, r25
	TCC0.CTRLFSET = (3 <<3); //reinicie el contador
 a64:	88 e1       	ldi	r24, 0x18	; 24
 a66:	80 93 09 08 	sts	0x0809, r24
	TCC0.PERL = perl;
 a6a:	40 93 26 08 	sts	0x0826, r20
	TCC0.PERH = perh;
 a6e:	60 93 27 08 	sts	0x0827, r22
	TCC0.INTCTRLA |= 3;
 a72:	80 91 06 08 	lds	r24, 0x0806
 a76:	83 60       	ori	r24, 0x03	; 3
 a78:	80 93 06 08 	sts	0x0806, r24
	TCC0.CTRLA |= (presc & 0x0f); 
 a7c:	80 91 00 08 	lds	r24, 0x0800
 a80:	2f 70       	andi	r18, 0x0F	; 15
 a82:	28 2b       	or	r18, r24
 a84:	20 93 00 08 	sts	0x0800, r18
 a88:	08 95       	ret

00000a8a <__vector_77>:
#include <avr/interrupt.h>

extern to_tcd0_delays_control to_d0_ctrl;

ISR(TCD0_OVF_vect)
{
 a8a:	1f 92       	push	r1
 a8c:	0f 92       	push	r0
 a8e:	0f b6       	in	r0, 0x3f	; 63
 a90:	0f 92       	push	r0
 a92:	11 24       	eor	r1, r1
 a94:	8f 93       	push	r24
 a96:	ef 93       	push	r30
 a98:	ff 93       	push	r31
	TCD0.INTCTRLA &= ~(3); //deshabilite interrupciones de tcc0
 a9a:	e0 e0       	ldi	r30, 0x00	; 0
 a9c:	f9 e0       	ldi	r31, 0x09	; 9
 a9e:	86 81       	ldd	r24, Z+6	; 0x06
 aa0:	8c 7f       	andi	r24, 0xFC	; 252
 aa2:	86 83       	std	Z+6, r24	; 0x06
	TCD0.CTRLA = 0; //detenga el timer
 aa4:	10 82       	st	Z, r1
	TCD0.CTRLFSET = (3 <<3); //reinicie el contador
 aa6:	88 e1       	ldi	r24, 0x18	; 24
 aa8:	81 87       	std	Z+9, r24	; 0x09
	to_d0_ctrl.banderas = TO_TCD0_FIN_bm; //indique que hubo un fin de conteo
 aaa:	82 e0       	ldi	r24, 0x02	; 2
 aac:	80 93 07 20 	sts	0x2007, r24
}
 ab0:	ff 91       	pop	r31
 ab2:	ef 91       	pop	r30
 ab4:	8f 91       	pop	r24
 ab6:	0f 90       	pop	r0
 ab8:	0f be       	out	0x3f, r0	; 63
 aba:	0f 90       	pop	r0
 abc:	1f 90       	pop	r1
 abe:	18 95       	reti

00000ac0 <To_tcd0_Init>:

void To_tcd0_Init(volatile to_tcd0_delays_control *to_d0_ctrl)
{
	to_d0_ctrl->banderas = 0;
 ac0:	fc 01       	movw	r30, r24
 ac2:	10 82       	st	Z, r1
 ac4:	08 95       	ret

00000ac6 <_exit>:
 ac6:	f8 94       	cli

00000ac8 <__stop_program>:
 ac8:	ff cf       	rjmp	.-2      	; 0xac8 <__stop_program>
